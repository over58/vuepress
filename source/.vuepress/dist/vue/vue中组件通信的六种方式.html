<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue中组件间的六种通信方式 | Adroi媒体API 接口文档</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="Adroi">
    <link rel="preload" href="/assets/css/0.styles.7950d16d.css" as="style"><link rel="preload" href="/assets/js/app.a8f039a7.js" as="script"><link rel="preload" href="/assets/js/2.b233f276.js" as="script"><link rel="preload" href="/assets/js/100.a2bf971c.js" as="script"><link rel="prefetch" href="/assets/js/10.45b68d43.js"><link rel="prefetch" href="/assets/js/101.6bfd7c76.js"><link rel="prefetch" href="/assets/js/102.976aec73.js"><link rel="prefetch" href="/assets/js/103.f9dda5bb.js"><link rel="prefetch" href="/assets/js/104.7a2c044c.js"><link rel="prefetch" href="/assets/js/105.254fc915.js"><link rel="prefetch" href="/assets/js/106.f41915af.js"><link rel="prefetch" href="/assets/js/107.a66fa4f8.js"><link rel="prefetch" href="/assets/js/108.9b6c69dc.js"><link rel="prefetch" href="/assets/js/109.f1614e55.js"><link rel="prefetch" href="/assets/js/11.1d47dcc9.js"><link rel="prefetch" href="/assets/js/110.48b16839.js"><link rel="prefetch" href="/assets/js/111.d4a62b82.js"><link rel="prefetch" href="/assets/js/112.a5d6d308.js"><link rel="prefetch" href="/assets/js/113.5676d524.js"><link rel="prefetch" href="/assets/js/114.35a64e8e.js"><link rel="prefetch" href="/assets/js/115.4eb6bffb.js"><link rel="prefetch" href="/assets/js/116.36f3e1e4.js"><link rel="prefetch" href="/assets/js/117.6de94982.js"><link rel="prefetch" href="/assets/js/12.bed0e105.js"><link rel="prefetch" href="/assets/js/13.0a5eac21.js"><link rel="prefetch" href="/assets/js/14.7bfc5893.js"><link rel="prefetch" href="/assets/js/15.06f779a9.js"><link rel="prefetch" href="/assets/js/16.9fb99a2c.js"><link rel="prefetch" href="/assets/js/17.89c79110.js"><link rel="prefetch" href="/assets/js/18.48846e09.js"><link rel="prefetch" href="/assets/js/19.d166835e.js"><link rel="prefetch" href="/assets/js/20.c42b4af5.js"><link rel="prefetch" href="/assets/js/21.c826a5fe.js"><link rel="prefetch" href="/assets/js/22.f7c5eb29.js"><link rel="prefetch" href="/assets/js/23.2a8387c7.js"><link rel="prefetch" href="/assets/js/24.1c8761a8.js"><link rel="prefetch" href="/assets/js/25.df9afda7.js"><link rel="prefetch" href="/assets/js/26.254a37a7.js"><link rel="prefetch" href="/assets/js/27.763eb91e.js"><link rel="prefetch" href="/assets/js/28.5fde24ce.js"><link rel="prefetch" href="/assets/js/29.3194dc2b.js"><link rel="prefetch" href="/assets/js/3.9af03473.js"><link rel="prefetch" href="/assets/js/30.adf415e7.js"><link rel="prefetch" href="/assets/js/31.0d9487fa.js"><link rel="prefetch" href="/assets/js/32.b09a0d09.js"><link rel="prefetch" href="/assets/js/33.ac311d11.js"><link rel="prefetch" href="/assets/js/34.0f57c1f7.js"><link rel="prefetch" href="/assets/js/35.fc139df6.js"><link rel="prefetch" href="/assets/js/36.cd5e93dc.js"><link rel="prefetch" href="/assets/js/37.92b4ef45.js"><link rel="prefetch" href="/assets/js/38.200d8d29.js"><link rel="prefetch" href="/assets/js/39.49215cf6.js"><link rel="prefetch" href="/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/assets/js/40.d967755e.js"><link rel="prefetch" href="/assets/js/41.3d11424b.js"><link rel="prefetch" href="/assets/js/42.ddb02fd2.js"><link rel="prefetch" href="/assets/js/43.72451ce4.js"><link rel="prefetch" href="/assets/js/44.dda78bfd.js"><link rel="prefetch" href="/assets/js/45.5b7bcf15.js"><link rel="prefetch" href="/assets/js/46.e8267815.js"><link rel="prefetch" href="/assets/js/47.a31ff353.js"><link rel="prefetch" href="/assets/js/48.72d2784b.js"><link rel="prefetch" href="/assets/js/49.2f5bc428.js"><link rel="prefetch" href="/assets/js/5.f5c0ce10.js"><link rel="prefetch" href="/assets/js/50.034785a8.js"><link rel="prefetch" href="/assets/js/51.175ebded.js"><link rel="prefetch" href="/assets/js/52.03ba2ff7.js"><link rel="prefetch" href="/assets/js/53.5242c91c.js"><link rel="prefetch" href="/assets/js/54.ca3f953a.js"><link rel="prefetch" href="/assets/js/55.1a5c5c9f.js"><link rel="prefetch" href="/assets/js/56.4d18a0bc.js"><link rel="prefetch" href="/assets/js/57.7cf39605.js"><link rel="prefetch" href="/assets/js/58.05f13011.js"><link rel="prefetch" href="/assets/js/59.911c3751.js"><link rel="prefetch" href="/assets/js/6.b4a5dcc0.js"><link rel="prefetch" href="/assets/js/60.b4a8a69b.js"><link rel="prefetch" href="/assets/js/61.bc7b4786.js"><link rel="prefetch" href="/assets/js/62.0884aba5.js"><link rel="prefetch" href="/assets/js/63.3a4807c0.js"><link rel="prefetch" href="/assets/js/64.a73cbe1c.js"><link rel="prefetch" href="/assets/js/65.9ce55b96.js"><link rel="prefetch" href="/assets/js/66.63299762.js"><link rel="prefetch" href="/assets/js/67.24873c55.js"><link rel="prefetch" href="/assets/js/68.e25a440a.js"><link rel="prefetch" href="/assets/js/69.2b08dddd.js"><link rel="prefetch" href="/assets/js/7.7026210c.js"><link rel="prefetch" href="/assets/js/70.36069df9.js"><link rel="prefetch" href="/assets/js/71.020da373.js"><link rel="prefetch" href="/assets/js/72.be9a4443.js"><link rel="prefetch" href="/assets/js/73.39a6064f.js"><link rel="prefetch" href="/assets/js/74.4594d1a5.js"><link rel="prefetch" href="/assets/js/75.1cdcb0c8.js"><link rel="prefetch" href="/assets/js/76.0195b2cc.js"><link rel="prefetch" href="/assets/js/77.615e5834.js"><link rel="prefetch" href="/assets/js/78.d7db8490.js"><link rel="prefetch" href="/assets/js/79.f3d6c5a0.js"><link rel="prefetch" href="/assets/js/8.bb748099.js"><link rel="prefetch" href="/assets/js/80.c4f67a4b.js"><link rel="prefetch" href="/assets/js/81.d51cedf7.js"><link rel="prefetch" href="/assets/js/82.3f27cee9.js"><link rel="prefetch" href="/assets/js/83.89df6e98.js"><link rel="prefetch" href="/assets/js/84.258ae313.js"><link rel="prefetch" href="/assets/js/85.69d467bd.js"><link rel="prefetch" href="/assets/js/86.cee6ae45.js"><link rel="prefetch" href="/assets/js/87.a2512d98.js"><link rel="prefetch" href="/assets/js/88.e33945a6.js"><link rel="prefetch" href="/assets/js/89.ac3d4c85.js"><link rel="prefetch" href="/assets/js/9.6341ef08.js"><link rel="prefetch" href="/assets/js/90.31bd1ef5.js"><link rel="prefetch" href="/assets/js/91.60f3687a.js"><link rel="prefetch" href="/assets/js/92.cb37f837.js"><link rel="prefetch" href="/assets/js/93.903d1935.js"><link rel="prefetch" href="/assets/js/94.59089737.js"><link rel="prefetch" href="/assets/js/95.4a6d7e03.js"><link rel="prefetch" href="/assets/js/96.1f626ad6.js"><link rel="prefetch" href="/assets/js/97.7b9a3517.js"><link rel="prefetch" href="/assets/js/98.00872dff.js"><link rel="prefetch" href="/assets/js/99.38d137f2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7950d16d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Adroi媒体API 接口文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/apiword.html" class="nav-link">
  接口定义
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/apiword.html" class="nav-link">
  接口定义
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>chart</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>nodejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>other</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/Vue是什么.html" class="sidebar-link">Vue是什么</a></li><li><a href="/vue/count-to组件.html" class="sidebar-link">count-to组件</a></li><li><a href="/vue/iview组件探索.html" class="sidebar-link">iview组件探索</a></li><li><a href="/vue/timeline样式实现.html" class="sidebar-link">timeline样式实现</a></li><li><a href="/vue/vue-awesome-swiper的坑.html" class="sidebar-link">vue-awesome-swiper的坑</a></li><li><a href="/vue/vue-cli3中iview按需引入.html" class="sidebar-link">vue-cli3中iview按需引入</a></li><li><a href="/vue/vue-directive.html" class="sidebar-link">vue-directive</a></li><li><a href="/vue/vue-intro使用方法及注意点.html" class="sidebar-link">vue-intro使用方法及注意点</a></li><li><a href="/vue/vue中使用cytoscape绘制拓扑图方案.html" class="sidebar-link">vue中使用cytoscape绘制拓扑图方案</a></li><li><a href="/vue/vue中使用highcharts和echarts的实践.html" class="sidebar-link">vue中使用highcharts和echarts的实践</a></li><li><a href="/vue/vue中定时器问题.html" class="sidebar-link">vue中定时器问题</a></li><li><a href="/vue/vue中引入higcharts拓展模块.html" class="sidebar-link">vue中引入higcharts拓展模块</a></li><li><a href="/vue/vue中组件通信的六种方式.html" class="active sidebar-link">vue中组件间的六种通信方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue实现文件下载.html" class="sidebar-link">vue实现文件下载</a></li><li><a href="/vue/vue源码阅读.html" class="sidebar-link">vue源码阅读</a></li><li><a href="/vue/从js的属性描述符描述vue-js的响应式视图.html" class="sidebar-link">从js的属性描述符描述vue.js的响应式视图</a></li><li><a href="/vue/全屏显示组件.html" class="sidebar-link">全屏显示组件</a></li><li><a href="/vue/对于echarts图表随着浏览器窗口resize的优化.html" class="sidebar-link">对于echarts图表随着浏览器窗口resize的优化</a></li><li><a href="/vue/封装line和pie简单组件.html" class="sidebar-link">封装line和pie简单组件</a></li><li><a href="/vue/组件生命周期.html" class="sidebar-link">组件生命周期</a></li><li><a href="/vue/覆盖ui框架css原生样式.html" class="sidebar-link">覆盖ui框架css原生样式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="方法一-props、-emit"><a href="#方法一-props、-emit" class="header-anchor">#</a> 方法一 props、$emit</h3> <p>父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。</p> <h4 id="_1-父组件向子组件传值"><a href="#_1-父组件向子组件传值" class="header-anchor">#</a> 1.父组件向子组件传值</h4> <p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>    //App.vue父组件
    &lt;template&gt;
      &lt;div id=&quot;app&quot;&gt;
        &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    import Users from &quot;./components/Users&quot;
    export default {
      name: 'App',
      data(){
        return{
          users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]
        }
      },
      components:{
        &quot;users&quot;:Users
      }
    }
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    //users子组件
    &lt;template&gt;
      &lt;div class=&quot;hello&quot;&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;user in users&quot;&gt;{{user}}&lt;/li&gt;//遍历传递过来的值，然后呈现到页面
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    export default {
      name: 'HelloWorld',
      props:{
        users:{           //这个就是父组件中子标签自定义名字\
          type:Array,
          required:true
        }
      }
    }
    &lt;/script&gt;
</code></pre></div><p>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</p> <h4 id="_2-子组件向父组件传值-通过事件形式"><a href="#_2-子组件向父组件传值-通过事件形式" class="header-anchor">#</a> 2.子组件向父组件传值（通过事件形式）</h4> <p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p> <div class="language- extra-class"><pre class="language-text"><code>    // 子组件
    &lt;template&gt;
      &lt;header&gt;
        &lt;h1 @click=&quot;changeTitle&quot;&gt;{{title}}&lt;/h1&gt;//绑定一个点击事件
      &lt;/header&gt;
    &lt;/template&gt;
    &lt;script&gt;
    export default {
      name: 'app-header',
      data() {
        return {
          title:&quot;Vue.js Demo&quot;
        }
      },
      methods:{
        changeTitle() {
          this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件  传递值“子向父组件传值”
        }
      }
    }
    &lt;/script&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    // 父组件
    &lt;template&gt;
      &lt;div id=&quot;app&quot;&gt;
        &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致
       // updateTitle($event)接受传递过来的文字
        &lt;h2&gt;{{title}}&lt;/h2&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    import Header from &quot;./components/Header&quot;
    export default {
      name: 'App',
      data(){
        return{
          title:&quot;传递的是一个值&quot;
        }
      },
      methods:{
        updateTitle(e){   //声明这个函数
          this.title = e;
        }
      },
      components:{
       &quot;app-header&quot;:Header,
      }
    }
    &lt;/script&gt;
</code></pre></div><p>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</p> <h3 id="方法二、-emit-on"><a href="#方法二、-emit-on" class="header-anchor">#</a> 方法二、 $emit　/ $on</h3> <p>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p> <h4 id="_1-具体实现方式"><a href="#_1-具体实现方式" class="header-anchor">#</a> 1.具体实现方式：</h4> <div class="language- extra-class"><pre class="language-text"><code>  var Event=new Vue();
  Event.$emit(事件名,数据);
  Event.$on(事件名,data =&gt; {});
</code></pre></div><h4 id="_2-举个例子"><a href="#_2-举个例子" class="header-anchor">#</a> 2.举个例子</h4> <p>假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据</p> <div class="language- extra-class"><pre class="language-text"><code>    &lt;div id=&quot;itany&quot;&gt;
        &lt;my-a&gt;&lt;/my-a&gt;
        &lt;my-b&gt;&lt;/my-b&gt;
        &lt;my-c&gt;&lt;/my-c&gt;
    &lt;/div&gt;
    &lt;template id=&quot;a&quot;&gt;
      &lt;div&gt;
        &lt;h3&gt;A组件：{{name}}&lt;/h3&gt;
        &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;template id=&quot;b&quot;&gt;
      &lt;div&gt;
        &lt;h3&gt;B组件：{{age}}&lt;/h3&gt;
        &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;template id=&quot;c&quot;&gt;
      &lt;div&gt;
        &lt;h3&gt;C组件：{{name}}，{{age}}&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    var Event = new Vue();//定义一个空的Vue实例
    var A = {
        template: '#a',
        data() {
          return {
            name: 'tom'
          }
        },
        methods: {
          send() {
            Event.$emit('data-a', this.name);
          }
        }
    }
    var B = {
        template: '#b',
        data() {
          return {
            age: 20
          }
        },
        methods: {
          send() {
            Event.$emit('data-b', this.age);
          }
        }
    }
    var C = {
        template: '#c',
        data() {
          return {
            name: '',
            age: &quot;&quot;
          }
        },
        mounted() {//在模板编译完成后执行
         Event.$on('data-a',name =&gt; {
             this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event
         })
         Event.$on('data-b',age =&gt; {
             this.age = age;
         })
        }
    }
    var vm = new Vue({
        el: '#itany',
        components: {
          'my-a': A,
          'my-b': B,
          'my-c': C
        }
    });    
    &lt;/script&gt;
</code></pre></div><p><img src="/images/vue/eventBus.gif" alt="eventBus">
监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p> <h3 id="方法三、vuex"><a href="#方法三、vuex" class="header-anchor">#</a> 方法三、vuex</h3> <p><img src="/images/vue/vuex.png" alt="vuex"></p> <h4 id="_1-简要介绍vuex原理"><a href="#_1-简要介绍vuex原理" class="header-anchor">#</a> 1.简要介绍Vuex原理</h4> <p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p> <h4 id="_2-简要介绍各模块在流程中的功能"><a href="#_2-简要介绍各模块在流程中的功能" class="header-anchor">#</a> 2.简要介绍各模块在流程中的功能：</h4> <ul><li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li> <li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li> <li>actions：操作行为处理模块,由组件中的 $store.dispatch('action 名称',data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li> <li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li> <li>mutations：状态改变操作方法，由actions中的 commit('mutation 名称')来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li> <li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li> <li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul> <h4 id="_3-vuex与localstorage"><a href="#_3-vuex与localstorage" class="header-anchor">#</a> 3.Vuex与localStorage</h4> <p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</p> <div class="language- extra-class"><pre class="language-text"><code>    let defaultCity = &quot;上海&quot;
    try {   // 用户关闭了本地存储功能，此时在外层加个try...catch
      if (!defaultCity){
        defaultCity = JSON.parse(window.localStorage.getItem('defaultCity'))
      }
    }catch(e){}
    export default new Vuex.Store({
      state: {
        city: defaultCity
      },
      mutations: {
        changeCity(state, city) {
          state.city = city
          try {
          window.localStorage.setItem('defaultCity', JSON.stringify(state.city));
          // 数据改变的时候把数据拷贝一份保存到localStorage里面
          } catch (e) {}
        }
      }
    })
</code></pre></div><p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p> <div class="language- extra-class"><pre class="language-text"><code>    JSON.stringify(state.subscribeList);   // array -&gt; string
    JSON.parse(window.localStorage.getItem(&quot;subscribeList&quot;));    // string -&gt; array 
</code></pre></div><h3 id="方法四、-attrs-listeners"><a href="#方法四、-attrs-listeners" class="header-anchor">#</a> 方法四、 $attrs　/ $listeners</h3> <p>1.简介
多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法---- $attrs/ $listeners
$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 interitAttrs 选项一起使用。
$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件
接下来我们看个跨级通信的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>    // index.vue
    &lt;template&gt;
      &lt;div&gt;
        &lt;h2&gt;浪里行舟&lt;/h2&gt;
        &lt;child-com1
          :foo=&quot;foo&quot;
          :boo=&quot;boo&quot;
          :coo=&quot;coo&quot;
          :doo=&quot;doo&quot;
          title=&quot;前端工匠&quot;
        &gt;&lt;/child-com1&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);
    export default {
      components: { childCom1 },
      data() {
        return {
          foo: &quot;Javascript&quot;,
          boo: &quot;Html&quot;,
          coo: &quot;CSS&quot;,
          doo: &quot;Vue&quot;
        };
      }
    };
    &lt;/script&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    // childCom1.vue
    &lt;template class=&quot;border&quot;&gt;
      &lt;div&gt;
        &lt;p&gt;foo: {{ foo }}&lt;/p&gt;
        &lt;p&gt;childCom1的$attrs: {{ $attrs }}&lt;/p&gt;
        &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);
    export default {
      components: {
        childCom2
      },
      inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性
      props: {
        foo: String // foo作为props属性绑定
      },
      created() {
        console.log(this.$attrs); // { &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; }
      }
    };
    &lt;/script&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    // childCom2.vue
    &lt;template&gt;
      &lt;div class=&quot;border&quot;&gt;
        &lt;p&gt;boo: {{ boo }}&lt;/p&gt;
        &lt;p&gt;childCom2: {{ $attrs }}&lt;/p&gt;
        &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);
    export default {
      components: {
        childCom3
      },
      inheritAttrs: false,
      props: {
        boo: String
      },
      created() {
        console.log(this.$attrs); // { &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; }
      }
    };
    &lt;/script&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>    // childCom3.vue
    &lt;template&gt;
      &lt;div class=&quot;border&quot;&gt;
        &lt;p&gt;childCom3: {{ $attrs }}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    export default {
      props: {
        coo: String,
        title: String
      }
    };
    &lt;/script&gt;
</code></pre></div><p><img src="/$attrs%E5%92%8C$listeners.png" alt="$attrs和$listeners">
$attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了 $attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。
简单来说： $attrs与 $listeners 是两个对象， $attrs 里存放的是父组件中绑定的非 Props 属性， $listeners里存放的是父组件中绑定的非原生事件。</p> <h3 id="方法五、provide-inject"><a href="#方法五、provide-inject" class="header-anchor">#</a> 方法五、provide/inject</h3> <h4 id="_1-简介"><a href="#_1-简介" class="header-anchor">#</a> 1.简介</h4> <p>Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p> <h4 id="_2-举个例子-2"><a href="#_2-举个例子-2" class="header-anchor">#</a> 2.举个例子</h4> <p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p> <div class="language- extra-class"><pre class="language-text"><code>    // A.vue
    export default {
      provide: {
        name: '浪里行舟'
      }
    }
    // B.vue
    export default {
      inject: ['name'],
      mounted () {
        console.log(this.name);  // 浪里行舟
      }
    }
</code></pre></div><p>可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 浪里行舟，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。
需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的----vue官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的</p> <h4 id="_3-provide与inject-怎么实现数据响应式"><a href="#_3-provide与inject-怎么实现数据响应式" class="header-anchor">#</a> 3.provide与inject 怎么实现数据响应式</h4> <p>一般来说，有两种办法：</p> <ul><li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li> <li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)
我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F不会跟着变（核心代码如下：）
<img src="/images/vue/provide%E4%B8%8Einject.png" alt="provide和inject"></li></ul> <div class="language- extra-class"><pre class="language-text"><code>    // A 组件 
    &lt;div&gt;
          &lt;h1&gt;A 组件&lt;/h1&gt;
          &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt;
          &lt;ChildrenB /&gt;
          &lt;ChildrenC /&gt;
    &lt;/div&gt;
    ......
      data() {
        return {
          color: &quot;blue&quot;
        };
      },
      // provide() {
      //   return {
      //     theme: {
      //       color: this.color //这种方式绑定的数据并不是可响应的
      //     } // 即A组件的color变化后，组件D、E、F不会跟着变
      //   };
      // },
      provide() {
        return {
          theme: this//方法一：提供祖先组件的实例
        };
      },
      methods: {
        changeColor(color) {
          if (color) {
            this.color = color;
          } else {
            this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;
          }
        }
      }
      // 方法二:使用vue2.6最新API Vue.observable 优化响应式 provide
      // provide() {
      //   this.theme = Vue.observable({
      //     color: &quot;blue&quot;
      //   });
      //   return {
      //     theme: this.theme
      //   };
      // },
      // methods: {
      //   changeColor(color) {
      //     if (color) {
      //       this.theme.color = color;
      //     } else {
      //       this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;
      //     }
      //   }
      // }
    // F 组件 
    &lt;template functional&gt;
      &lt;div class=&quot;border2&quot;&gt;
        &lt;h3 :style=&quot;{ color: injections.theme.color }&quot;&gt;F 组件&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/template&gt;
    &lt;script&gt;
    export default {
      inject: {
        theme: {
          //函数式组件取值不一样
          default: () =&gt; ({})
        }
      }
    };
    &lt;/script&gt;
</code></pre></div><p>虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p> <h3 id="方法六、-parent-children-ref"><a href="#方法六、-parent-children-ref" class="header-anchor">#</a> 方法六、 $parent / $children　＆ ref</h3> <ul><li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li> <li>$parent / $children：访问父 / 子实例
需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    // component-a 子组件
    export default {
      data () {
        return {
          title: 'Vue.js'
        }
      },
      methods: {
        sayHello () {
          window.alert('Hello');
        }
      }
    }
    // 父组件
    &lt;template&gt;
      &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;
    &lt;/template&gt;
    &lt;script&gt;
      export default {
        mounted () {
          const comA = this.$refs.comA;
          console.log(comA.title);  // Vue.js
          comA.sayHello();  // 弹窗
        }
      }
    &lt;/script&gt;
</code></pre></div><p>不过，这两种方法的弊端是，无法在跨级或兄弟间通信。</p> <div class="language- extra-class"><pre class="language-text"><code>    // parent.vue
    &lt;component-a&gt;&lt;/component-a&gt;
    &lt;component-b&gt;&lt;/component-b&gt;
    &lt;component-b&gt;&lt;/component-b&gt;
</code></pre></div><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>常见使用场景可以分为三类：</p> <ul><li>父子通信： 父向子传递数据是通过 props，子向父是通过 events（ $emit）；通过父链 / 子链也可以通信（ $parent / $children）；ref 也可以访问组件实例；provide / inject API； $attrs/$listeners</li> <li>兄弟通信： Bus；Vuex</li> <li>跨级通信： Bus；Vuex；provide / inject API、 $attrs/$listeners</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue/vue中引入higcharts拓展模块.html" class="prev">
        vue中引入higcharts拓展模块
      </a></span> <span class="next"><a href="/vue/vue实现文件下载.html">
        vue实现文件下载
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a8f039a7.js" defer></script><script src="/assets/js/2.b233f276.js" defer></script><script src="/assets/js/100.a2bf971c.js" defer></script>
  </body>
</html>
