(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{434:function(t,e,n){"use strict";n.r(e);var s=n(42),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"误区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#误区"}},[t._v("#")]),t._v(" 误区")]),t._v(" "),n("p",[t._v("一直以来都以为在函数参数传递的过程中遵循： 普通类型使用值传递，对象使用引用传递。很多文章也这么说，现在发现大错特错了。下面举个例子来说吧")]),t._v(" "),n("h3",{attrs:{id:"demo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#demo"}},[t._v("#")]),t._v(" demo")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\n\x3c!-- 在函数中对参数进行了重新赋值 --\x3e\nfunction setName(obj) {\n  obj.name = "Nicholas";\n  obj = new Object();\n  obj.name = "Greg";\n}\n\n// 定义一个全局变量\nvar person = new Object();\nsetName(person);\n// 如果对象是引用传递的话，name应该是"Greg"的，事实上结果是Nicholas\nconsole.log(person.name);\n')])])]),n("h3",{attrs:{id:"解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[t._v("#")]),t._v(" 解析")]),t._v(" "),n("p",[t._v("在js的参数传递中，"),n("strong",[t._v("有且只有值传递一种")]),t._v("。但是变量的访问却有"),n("strong",[t._v("按值访问")]),t._v("和"),n("strong",[t._v("按引用访问")]),t._v("。\n在传递对象参数的过程中，实际上是将对象地址的一个拷贝传过去了，就是一个string类型的值。\n如果是修改对象的属性的话，使用按引用访问的方式，找到堆中的对象进行修改。\n但是当对参数重新赋值的时候，只不过是改变了obj的存储的string类型的地址值，不存在访问的操作，也就对原始的对象无影响了,obj指向了一个全新的对象，和原来的对象断了联系。")])])}),[],!1,null,null,null);e.default=a.exports}}]);