(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{382:function(t,n,s){"use strict";s.r(n);var e=s(42),a=Object(e.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("###　简单介绍\n谈到JAVASCRIPT的继承，只有一种结构：对象。每个对象都有一个私有属性__proto__ 指向它的原型对象(prototype) . 原型对象也有自己的__proto__ ,层层向上直到一个对象的原型对象为NULL.根据定义，NULL是没有原型的，并作为这个原型链的最后一个环节。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/prototype.png",alt:"js prototype"}})]),t._v(" "),s("p",[t._v("！！！ 实例对象的__proto__ 等于该对象构造函数的prototype\nps:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\nvar obj = {}\nobj.__proto__ === Object.prototype\n")])])]),t._v(" "),s("h3",{attrs:{id:"封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[t._v("#")]),t._v(" 封装")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var Book = function (id,name, price) {\n    // 私有属性\n    var num = 1\n    // 私有函数\n    function checkId(){\n    }\n    // 公有属性\n    this.id = id\n    this.name = name\n    this.price = price\n    // 公有函数\n    this.getName=function(){}\n    this.getPrice = function(){}\n    this.setName = function (name){this.name = name}\n    this.setPrice = function(price){this.price = price}\n    this.getNum = function(){return num}\n}\n//类静态公有属性（对象不能访问）\nBook.isChinese = true\n//类静态公有方法（对象不能访问）\nBook.resetTime = function(){}\n\nvar book = new Book('adf2323','js设计模式', 232)\nconsole.log(book.name, book.price, book.id)\nconsole.log(book.getNum())\n")])])]),s("p",[t._v("###　New的作用")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Function Book(id, name , price) {\n    Var this = {}\n    This.name = name\n    This.id = id\n    This.price = price\n    Return this\n}\n")])])]),s("h3",{attrs:{id:"类的原型对象的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类的原型对象的作用"}},[t._v("#")]),t._v(" 类的原型对象的作用")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("继承通过将父类的实例赋值给子类的原型对象。\n类的原型对象的作用就是为类的原型添加共有方法，但是类并不能直接访问这些函数和方法。当我实例化的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型__proto__ 指向父类的原型对象，这样就拥有了父类的原型对象上的属性和方法，并且这个新创建的对象可以访问到父类原型对象上到的属性和方法\n")])])]),s("h3",{attrs:{id:"常见的继承的几种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的继承的几种方式"}},[t._v("#")]),t._v(" 常见的继承的几种方式")]),t._v(" "),s("h4",{attrs:{id:"类式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类式继承"}},[t._v("#")]),t._v(" 类式继承")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("//声明父类\nfunction SuperClass(){}\n// 为父类添加共有方法\nSuperClass.prototype.getSuperValue=function(){}\n\n//声明子类\nfunction SubClass(){\n    this.subValue = false\n}\n\n//继承\nSubClass.prototype = new SuperClass();\n\n// 为子类添加共有方法\nSubClass.prototype.getSubValue = function (){\n    return this.subValue\n}\n\n缺点：由于子类通过其原型prototype 对父类进行实例化，继承了父类。所以说父类中的共有属性如果是引用类型，就会被子类中的所有实例共用，存在被修改的可能。\n")])])]),s("h4",{attrs:{id:"构造函数式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数式继承"}},[t._v("#")]),t._v(" 构造函数式继承")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function SuperClass(id){\n  this.books = ['js', 'html', 'css']\n  this.id = id\n}\n\nSuperClass.prototype.getSuperValue = function () {\n  console.log('getSuperValue')\n}\n\nfunction SubClass(id){\n  // 继承父类\n  SuperClass.call(this, id)\n}\n\n缺点：只继承了父类构造函数中的公有属性。如果一个函数后者变量想要被继承么，就必须放在父类构造函数中，这样创建的每个实例都会单独拥有一份而不能共用，这样违背了代码复用的原则。为了综合这两种模式的有点，后来有了组合式继承。\n")])])]),s("h4",{attrs:{id:"组合式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合式继承"}},[t._v("#")]),t._v(" 组合式继承")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function SuperClass(id){\n  // 将公有引用类型放在构造函数中\n  this.books = ['js', 'html', 'css']\n  this.id = id\n}\n\nSuperClass.prototype.getSuperValue = function () {\n  console.log('getSuperValue')\n}\n\nfunction SubClass(id){\n  // 继承父类中构造函数的属性和方法\n  SuperClass.call(this, id)\n}\nSubClass.prototype = new SuperClass()\nSubClass.prototype.getTime = function(){\n    \n}\n缺点： \nSuperClass.call(this, id)执行了一次父类构造函数\nnew SuperClass()又执行了一次父类构造函数\n")])])]),s("h4",{attrs:{id:"寄生组合式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合式继承"}},[t._v("#")]),t._v(" 寄生组合式继承")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function SuperClass(id){\n  // 将公有引用类型放在构造函数中\n  this.books = ['js', 'html', 'css']\n  this.id = id\n}\n\nSuperClass.prototype.getSuperValue = function () {\n  console.log('getSuperValue')\n}\n\nfunction SubClass(id){\n  // 继承父类中构造函数的属性和方法\n  SuperClass.call(this, id)\n}\nfunction inherit(subClass, superClass){\n    //定义了一个没有自有属性的对象\n    var F = function(){}\n    F.prototype = superClass.prototype\n    subClass.prototype = new F() // 干净的继承了父类的公有属性\n}\n")])])]),s("h4",{attrs:{id:"补充-inherit函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充-inherit函数"}},[t._v("#")]),t._v(" 补充：inherit函数")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('function inherit(p){\n    if(p === null) throw TypeError\n    if(Object.create){\n        return Object.create(p)\n    }\n    let t = typeof p\n    if(t !== "object" || t!== "function") throw TypeError\n    function F(){}\n    F.prototype = p\n    return new F();\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);