(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{443:function(n,t,e){"use strict";e.r(t);var r=e(42),s=Object(r.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("Vue中使用了定时器后在关闭页面后必须手动清理")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("方案一\n\ndata: {\n  tiemr: null  \n},\nmethod: {\n  method1 () {\n    this.timer = setInterval(()=> {\n      // logic \n    }, interval)\n  }  \n},\nbeforeDestroy() {\n    clearInterval(this.timer)\n    this.timer = null\n}\n\n\n方案二：\n\n通过$once来监听定时器，在beforeDestroy中可以被清除\n\n\n优点：这两段代码写在一起，不用特意定义一个data.timer,减少了数据监听的成本消耗\n缺点：适用于只有离开页面关闭定时器的情况，\nconst timer = setInterval(()=>{\n    // logic\n}, interval)\n\nthis.$once('hook:beforeDestroy', ()=>{\n    clearInterval(timer)\n})\n\nps: \n\n\ntemplate>\n  <div class=\"test\">\n    <Button @click=\"addInterval()\">add</Button>\n    <h1>测试</h1>\n    <router-view/>\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    addInterval () {\n      const timer = setInterval(() => {\n        console.log('aaa')\n      }, 100)\n      this.$once('hook:beforeDestroy', () => {\n        clearInterval(timer)\n      })\n    }\n  }\n}\n<\/script>\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);