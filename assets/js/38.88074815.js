(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{384:function(t,e,n){"use strict";n.r(e);var a=n(42),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"引言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[t._v("#")]),t._v(" 引言")]),t._v(" "),n("p",[t._v("其实，说起js的事件模型，有点基础的都能说几句， 分为三个阶段， 捕获-事件处理-冒泡，巴拉巴拉...。但是这并没有考虑到我们 "),n("strong",[t._v('"伟大"')]),t._v(" 的IE，有点考虑的不够全面。接下来系统性的详细的讲一波儿")]),t._v(" "),n("h3",{attrs:{id:"事件模型的前世今生"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件模型的前世今生"}},[t._v("#")]),t._v(" 事件模型的前世今生")]),t._v(" "),n("p",[t._v("故事源于传说中的浏览器大战，微软的 IE 和网景的Netspace Navigator。\nIE的事件流是冒泡 从里面往上面冒, netscape是从外部元素往内部元素捕获;后来出来了个W3C委员会，想要统一，为了兼容，宣布了后来的W3C事件模型（捕获-事件处理-冒泡），从此天下一统。")]),t._v(" "),n("h3",{attrs:{id:"事件的三种模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件的三种模型"}},[t._v("#")]),t._v(" 事件的三种模型")]),t._v(" "),n("h4",{attrs:{id:"dom0-原始事件模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dom0-原始事件模型"}},[t._v("#")]),t._v(" DOM0(原始事件模型)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<input id="myButton" type="button" value="Press Me" onclick="alert(\'thanks\');" >\n\nor\n\ndocument.getElementById("myButton").onclick = function () {alert(\'thanks\');}\n\n')])])]),n("p",[t._v("通常情况下事件监听函数如果返回一个值并且是false，则会阻止浏览器执行默认的动作")]),t._v(" "),n("p",[t._v("优点：")]),t._v(" "),n("blockquote",[n("p",[t._v("所有浏览器都兼容")])]),t._v(" "),n("p",[t._v("缺点：")]),t._v(" "),n("blockquote",[n("ol",[n("li",[t._v("代码耦合严重")]),t._v(" "),n("li",[t._v("事件监听器只能有一个，重复赋值，后面会覆盖前面的")]),t._v(" "),n("li",[t._v("没有事件的冒泡、委托等机制完成更为负载的情况")])])]),t._v(" "),n("h4",{attrs:{id:"ie"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ie"}},[t._v("#")]),t._v(" IE")]),t._v(" "),n("p",[t._v("IE将event作为window的一个属性。IE的事件模型只有两步，执行处理函数，然后冒泡。\n添加和移除事件监听的方式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('attachEvent( "eventType","handler")\n//其中evetType为事件的类型，如onclick，注意要加’on’。\n\ndetachEvent("eventType","handler" )\n')])])]),n("h4",{attrs:{id:"dom2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dom2"}},[t._v("#")]),t._v(" DOM2")]),t._v(" "),n("p",[t._v("事件分为三个阶段： 捕获-处理目标-冒泡（IE8以及更早版本不支持DOM事件流）")]),t._v(" "),n("ol",[n("li",[t._v("捕获阶段： 事件被从document一直向下传播到目标元素,在这过程中依次检查经过的节点是否注册了该事件的监听函数，若有则执行。")]),t._v(" "),n("li",[t._v("事件处理： 事件到达目标元素,执行目标元素的事件处理函数")]),t._v(" "),n("li",[t._v("冒泡：    事件从目标元素上升一直到达document，同样依次检查经过的节点是否注册了该事件的监听函数，有则执行。")])]),t._v(" "),n("h3",{attrs:{id:"事件对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件对象"}},[t._v("#")]),t._v(" 事件对象")]),t._v(" "),n("h4",{attrs:{id:"常用对象和属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用对象和属性"}},[t._v("#")]),t._v(" 常用对象和属性")]),t._v(" "),n("ul",[n("li",[t._v("DOM事件模型中的事件对象常用属性:")])]),t._v(" "),n("ol",[n("li",[t._v("type用于获取事件类型")]),t._v(" "),n("li",[t._v("currentTarget 当前正在处理的事件的节点，在事件捕获或冒泡阶段")]),t._v(" "),n("li",[t._v("target获取事件目标")]),t._v(" "),n("li",[t._v("stopPropagation()阻止事件冒泡")]),t._v(" "),n("li",[t._v("preventDefault()阻止事件默认行为")]),t._v(" "),n("li",[t._v("keyCode：按下的键的值；")]),t._v(" "),n("li",[t._v("stopImmediatePropagation() (DOM3)阻止任何事件的运行；详情看http://39.105.159.58:8080/2019/09/16/stopImmediatePropagation%E5%92%8CstopPropagation%E7%9A%84%E5%8C%BA%E5%88%AB/")])]),t._v(" "),n("ul",[n("li",[t._v("IE事件模型中的事件对象常用属性:")])]),t._v(" "),n("ol",[n("li",[t._v("type用于获取事件类型")]),t._v(" "),n("li",[t._v("srcElement获取事件目标")]),t._v(" "),n("li",[t._v("cancelBubble阻止事件冒泡")]),t._v(" "),n("li",[t._v("returnValue阻止事件默认行为")])]),t._v(" "),n("h4",{attrs:{id:"事件对象中和定位相关的属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件对象中和定位相关的属性"}},[t._v("#")]),t._v(" 事件对象中和定位相关的属性")]),t._v(" "),n("ol",[n("li",[t._v("x/y与clientX/clientY值一样，表示距浏览器可视区域（工具栏除外区域）左/上的距离；")]),t._v(" "),n("li",[t._v("pageX/pageY，距页面左/上的距离，它与clientX/clientY的区别是不随滚动条的位置变化；")]),t._v(" "),n("li",[t._v("screenX/screenY，距计算机显示器左/上的距离，拖动你的浏览器窗口位置可以看到变化；")]),t._v(" "),n("li",[t._v("layerX/layerY与offsetX/offsetY值一样，表示距有定位属性的父元素左/上的距离。")])]),t._v(" "),n("h3",{attrs:{id:"事件委托-代理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件委托-代理"}},[t._v("#")]),t._v(" 事件委托/代理")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<ul id="parent">\n  <li class="child">1</li>\n  <li class="child">2</li>\n  <li class="child">3</li>\n</ul>\n\n<script type="text/javascript">\n  //父元素\n  var dom= document.getElementById(\'parent\');\n\n  //父元素绑定事件，代理子元素的点击事件\n  dom.onclick= function(event) {\n    var event= event || window.event;\n    var curTarget= event.target || event.srcElement;\n\n    if (curTarget.tagName.toLowerCase() == \'li\') { //找到被代理的节点\n      //事件处理\n    }\n  }\n<\/script>\n')])])]),n("p",[t._v("优点：")]),t._v(" "),n("ol",[n("li",[t._v("节省内存占用，减少事件注册")]),t._v(" "),n("li",[t._v("新增子对象时无需再次对其绑定事件，适合动态添加元素")])]),t._v(" "),n("h3",{attrs:{id:"eventbus的事件模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventbus的事件模型"}},[t._v("#")]),t._v(" eventBus的事件模型")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n * 完整的思路就是，使用一个map存储 type：处理函数\n *  有两种存储形式\n *  type: function\n *  type: [function, funciton, ...]\n *  删除和添加的时候考虑到这两种情况就行了\n */\nclass EventEmitter{\n  constructor () {\n    this._events = this._events || new Map()\n    this._maxListeners = this._maxListeners || 10\n  }\n}\n\nEventEmitter.prototype.emit = function(type, ...args){\n  let handler = this._events.get(type)\n  if (Array.isArray(handler)) {\n    for(let i=0;i<handler.length;i++) {\n      if(args.length > 0) {\n        handler[i].apply(this, args)\n      }else {\n        handler[i].call(this)\n      }\n    }\n  }else {\n    if(args.length >0) {\n      handler.apply(this, args)\n    } else {\n      handler.call(this)\n    }\n  }\n  return true\n}\n\nEventEmitter.prototype.addListener = function(type, fn) {\n  const handler = this._events.get(type)\n  if(!handler) {\n    this._events.set(type, handler)\n  }else if(handler && typeof handler === 'function') {\n    this._events.set(type, [handler, fn])\n  }else {\n    handler.push(fn)\n  }\n}\n\nEventEmitter.prototype.removeListener = function(type, fn) {\n  const handler = this._events.get(type)\n  if(handler && typeof handler === 'function') {\n    this._events.delete(type)\n  } else {\n    let position = -1\n    for (let i=0;i<handler.length;i++) {\n      if (handler[i] === fn) {\n        position = i\n      }\n    }\n    if (position !== -1) {\n      handler.splice(position, 1)\n      if (handler.length === 1) {\n        this._events.set(type, handler[0])\n      }\n    } else {\n      return this\n    }\n  }\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);